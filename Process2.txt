backend/
config/config.go:
package config

import (
	"os"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

func ConnectDatabase() (*gorm.DB, error) {
	dbUser := os.Getenv("DB_USER")
	dbPassword := os.Getenv("DB_PASSWORD")
	dbName := os.Getenv("DB_NAME")
	dbHost := os.Getenv("DB_HOST")
	dbPort := os.Getenv("DB_PORT")

	dsn := dbUser + ":" + dbPassword + "@tcp(" + dbHost + ":" + dbPort + ")/" + dbName + "?charset=utf8mb4&parseTime=True&loc=Local"
	return gorm.Open(mysql.Open(dsn), &gorm.Config{})
}

graph/model/models_gen.go:
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

type Mutation struct {
}

type NewTodo struct {
	Text   string `json:"text"`
	UserID string `json:"userId"`
}

type Query struct {
}

type Todo struct {
	ID   string `json:"id"`
	Text string `json:"text"`
	Done bool   `json:"done"`
	User *User  `json:"user"`
}

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

graph/generated.go:
package graph

// This file should only contain generated code and not duplicate declarations.
// Ensure it does not redefine the `ResolverRoot` interface.

// Generated code here...

graph/resolver.go:
package graph

// ResolverRoot defines the interface that the Resolver must implement.
type ResolverRoot interface {
	Mutation() string
	Query() string
}

// Resolver implements the ResolverRoot interface.
type Resolver struct{}

// Mutation method implementation for the Resolver.
func (r *Resolver) Mutation() string {
	return "Mutation response"
}

// Query method implementation for the Resolver.
func (r *Resolver) Query() string {
	return "Query response"
}

graph/schema.graphqls:
type Form {
  id: ID!
  title: String!
  content: String!
}

type Query {
  forms: [Form!]!
}

input NewForm {
  title: String!
  content: String!
}

type Mutation {
  createForm(input: NewForm!): Form!
}

models/form.go:
package models

// Form represents a form structure.
type Form struct {
	Name string
}

// NewForm creates a new Form instance.
func NewForm(name string) *Form {
	return &Form{Name: name}
}

routes/routes.go:
package routes

import (
	"encoding/json"
	"net/http"

	"go-form/models"

	"github.com/gorilla/mux"
	"gorm.io/gorm"
)

func SetupRoutes(db *gorm.DB) *mux.Router {
	router := mux.NewRouter()

	router.HandleFunc("/api/forms", func(w http.ResponseWriter, r *http.Request) {
		if r.Method == http.MethodPost {
			var form models.Form
			if err := json.NewDecoder(r.Body).Decode(&form); err != nil {
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}
			db.Create(&form)
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(form)
		} else if r.Method == http.MethodGet {
			var forms []models.Form
			db.Find(&forms)
			json.NewEncoder(w).Encode(forms)
		}
	}).Methods(http.MethodPost, http.MethodGet)

	return router
}

main.go:
package main

import (
	"fmt"
	"go-form/graph"
	"go-form/models"
	"log"
	"net/http"
)

// main function to start the server
func main() {
	// Create a new form using the models package.
	form := models.NewForm("Sample Form")
	fmt.Println("Form Name:", form.Name)

	// Initialize resolvers.
	resolver := &graph.Resolver{}

	// Define your API routes
	http.HandleFunc("/mutation", func(w http.ResponseWriter, r *http.Request) {
		// Handle mutation logic here
		fmt.Fprintln(w, resolver.Mutation())
	})

	http.HandleFunc("/query", func(w http.ResponseWriter, r *http.Request) {
		// Handle query logic here
		fmt.Fprintln(w, resolver.Query())
	})

	// Start the server
	fmt.Println("Server is running on http://localhost:8080")
	if err := http.ListenAndServe(":8080", nil); err != nil {
		log.Fatal(err)
	}
}

This is the code for the backend part till now.

Instruction: The project is for creating a form builder with Golang and gqlgen for the backend and API, and react for front end. also need API so others can use this form builder.
The form builder should contains: 3 parts in the display, on the left there should be the componenets to drag and drop (text, date, dropdown etc) and the list of forms, in the middle section we can create the form builder by drag and drop, on the right there should be more options for the components. 

1. Every submitted form by the user should be saved as a single schema (table) in the database.

Now create the frontend part aligning with the backend codes.